{"version":3,"file":"static/js/Worker.19088a8b.worker.js","mappings":"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","sources":["../comsync/webpack/universalModuleDefinition","../comsync/external umd \"comlink\"","../comsync/external umd \"sync-message\"","../comsync/webpack/bootstrap","../comsync/webpack/runtime/compat get default export","../comsync/webpack/runtime/define property getters","../comsync/webpack/runtime/hasOwnProperty shorthand","../comsync/webpack/runtime/make namespace object","../comsync/lib/index.ts","../pyodide-worker-runner/webpack/universalModuleDefinition","../pyodide-worker-runner/lib/pyodide_worker_runner.py","../pyodide-worker-runner/node_modules/retry/index.js","../pyodide-worker-runner/node_modules/retry/lib/retry.js","../pyodide-worker-runner/node_modules/retry/lib/retry_operation.js","../pyodide-worker-runner/external umd \"comlink\"","../pyodide-worker-runner/external umd \"comsync\"","../pyodide-worker-runner/external umd \"pyodide\"","../pyodide-worker-runner/webpack/bootstrap","../pyodide-worker-runner/webpack/runtime/define property getters","../pyodide-worker-runner/webpack/runtime/hasOwnProperty shorthand","../pyodide-worker-runner/webpack/runtime/make namespace object","../pyodide-worker-runner/node_modules/p-retry/index.js","../pyodide-worker-runner/lib/index.ts","../node_modules/pyodide/pyodide.js","../syncMessage/webpack/universalModuleDefinition","../syncMessage/webpack/bootstrap","../syncMessage/webpack/runtime/define property getters","../syncMessage/webpack/runtime/hasOwnProperty shorthand","../syncMessage/webpack/runtime/make namespace object","../syncMessage/lib/index.ts","../node_modules/comlink/src/comlink.ts","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","Worker.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"sync-message\"), require(\"comlink\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"sync-message\", \"comlink\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"comsync\"] = factory(require(\"sync-message\"), require(\"comlink\"));\n\telse\n\t\troot[\"comsync\"] = factory(root[\"sync-message\"], root[\"comlink\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__746__, __WEBPACK_EXTERNAL_MODULE__272__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__272__;","module.exports = __WEBPACK_EXTERNAL_MODULE__746__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {Channel, readMessage, uuidv4, writeMessage} from \"sync-message\";\nimport * as Comlink from \"comlink\";\n\nexport class InterruptError extends Error {\n  // To avoid having to use instanceof\n  public readonly type = \"InterruptError\";\n}\n\nexport class NoChannelError extends Error {\n  // To avoid having to use instanceof\n  public readonly type = \"NoChannelError\";\n}\n\nexport class SyncClient<T = any> {\n  public interrupter?: () => void;\n  public state: \"idle\" | \"running\" | \"awaitingMessage\" | \"sleeping\" = \"idle\";\n  public worker: Worker;\n  public workerProxy: Comlink.Remote<T>;\n\n  private _interruptRejector?: (reason?: any) => void;\n  private _interruptPromise?: Promise<void>;\n\n  private _messageIdBase = \"\";\n  private _messageIdSeq = 0;\n\n  private _awaitingMessageResolve?: () => void;\n\n  public constructor(\n    public workerCreator: () => Worker,\n    public channel?: Channel | null,\n  ) {\n    this._start();\n  }\n\n  public async interrupt() {\n    if (this.state === \"idle\") {\n      return;\n    }\n\n    if (this.state === \"awaitingMessage\" || this.state === \"sleeping\") {\n      await this._writeMessage({interrupted: true});\n      return;\n    }\n\n    if (this.interrupter) {\n      await this.interrupter();\n      return;\n    }\n\n    this.terminate();\n    this._start();\n  }\n\n  public async call(proxyMethod: any, ...args: any[]) {\n    if (this.state !== \"idle\") {\n      throw new Error(`State is ${this.state}, not idle`);\n    }\n\n    let runningThisTask = true;\n    this.state = \"running\";\n\n    this._messageIdBase = uuidv4();\n    this._messageIdSeq = 0;\n\n    const syncMessageCallback: SyncMessageCallback = (status) => {\n      if (!runningThisTask || status === \"init\") {\n        return;\n      }\n\n      if (status === \"reading\") {\n        this.state = \"awaitingMessage\";\n        this._messageIdSeq++;\n        this._awaitingMessageResolve?.();\n      } else if (status === \"sleeping\") {\n        this.state = \"sleeping\";\n        this._messageIdSeq++;\n      } else if (status === \"slept\") {\n        this.state = \"running\";\n      }\n    };\n\n    this._interruptPromise = new Promise(\n      (resolve, reject) => (this._interruptRejector = reject),\n    );\n\n    try {\n      return await Promise.race([\n        proxyMethod(\n          this.channel,\n          Comlink.proxy(syncMessageCallback),\n          this._messageIdBase,\n          ...args,\n        ),\n        this._interruptPromise,\n      ]);\n    } finally {\n      runningThisTask = false;\n      this._reset();\n    }\n  }\n\n  public async writeMessage(message: any) {\n    if (this.state === \"idle\" || !this._messageIdBase) {\n      throw new Error(\"No active call to send a message to.\");\n    }\n\n    if (this.state !== \"awaitingMessage\") {\n      if (this._awaitingMessageResolve) {\n        throw new Error(\n          \"Not waiting for message, and another write is already queued.\",\n        );\n      }\n\n      await new Promise<void>((resolve) => {\n        this._awaitingMessageResolve = resolve;\n      });\n      delete this._awaitingMessageResolve;\n    }\n\n    await this._writeMessage({message});\n  }\n\n  public terminate() {\n    this._interruptRejector?.(new InterruptError(\"Worker terminated\"));\n    this.workerProxy[Comlink.releaseProxy]();\n    this.worker.terminate();\n    delete this.workerProxy;\n    delete this.worker;\n  }\n\n  private async _writeMessage(message: any) {\n    this.state = \"running\";\n    const messageId = makeMessageId(this._messageIdBase, this._messageIdSeq);\n    await writeMessage(this.channel, message, messageId);\n  }\n\n  private _start() {\n    this._reset();\n    this.worker = this.workerCreator();\n    this.workerProxy = Comlink.wrap<T>(this.worker);\n  }\n\n  private _reset() {\n    this.state = \"idle\";\n    delete this._interruptPromise;\n    delete this._interruptRejector;\n    delete this._awaitingMessageResolve;\n    delete this._messageIdBase;\n  }\n}\n\nexport interface SyncExtras {\n  channel: Channel | null;\n  readMessage: () => any;\n  syncSleep: (ms: number) => void;\n}\n\ntype SyncMessageCallbackStatus = \"init\" | \"reading\" | \"sleeping\" | \"slept\";\ntype SyncMessageCallback = (status: SyncMessageCallbackStatus) => void;\n\nexport function syncExpose<T extends any[], R>(\n  func: (extras: SyncExtras, ...args: T) => R,\n) {\n  return async function (\n    channel: Channel | null,\n    syncMessageCallback: SyncMessageCallback,\n    messageIdBase: string,\n    ...args: T\n  ): Promise<R> {\n    await syncMessageCallback(\"init\");\n    let messageIdSeq = 0;\n\n    function fullSyncMessageCallback(\n      status: \"reading\" | \"sleeping\",\n      options?: {timeout: number},\n    ) {\n      if (!channel) {\n        throw new NoChannelError();\n      }\n      syncMessageCallback(status);\n      const messageId = makeMessageId(messageIdBase, ++messageIdSeq);\n      const response = readMessage(channel, messageId, options);\n      if (response) {\n        const {message, interrupted} = response;\n        if (interrupted) {\n          throw new InterruptError();\n        }\n        return message;\n      } else if (status === \"sleeping\") {\n        syncMessageCallback(\"slept\");\n      }\n    }\n\n    const extras: SyncExtras = {\n      channel,\n      readMessage() {\n        return fullSyncMessageCallback(\"reading\");\n      },\n      syncSleep(ms: number) {\n        if (!(ms > 0)) {\n          return;\n        }\n        fullSyncMessageCallback(\"sleeping\", {timeout: ms});\n      },\n    };\n    return func(extras, ...args);\n  };\n}\n\nfunction makeMessageId(base: string, seq: number) {\n  return `${base}-${seq}`;\n}\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"comsync\"), require(\"comlink\"), require(\"pyodide\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"comsync\", \"comlink\", \"pyodide\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pyodide-worker-runner\"] = factory(require(\"comsync\"), require(\"comlink\"), require(\"pyodide\"));\n\telse\n\t\troot[\"pyodide-worker-runner\"] = factory(root[\"comsync\"], root[\"comlink\"], root[\"pyodide\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__422__, __WEBPACK_EXTERNAL_MODULE__272__, __WEBPACK_EXTERNAL_MODULE__28__) => {\nreturn ","export default \"import importlib\\nimport sys\\nfrom typing import Callable, Literal, Union, TypedDict\\n\\ntry:\\n    from pyodide.code import find_imports  # noqa\\nexcept ImportError:\\n    from pyodide import find_imports  # noqa\\n\\nimport pyodide_js  # noqa\\n\\nsys.setrecursionlimit(400)\\n\\n\\nclass InstallEntry(TypedDict):\\n    module: str\\n    package: str\\n\\n\\ndef find_imports_to_install(imports: list[str]) -> list[InstallEntry]:\\n    \\\"\\\"\\\"\\n    Given a list of module names being imported, return a list of dicts\\n    representing the packages that need to be installed to import those modules.\\n    The returned list will only contain modules that aren't already installed.\\n    Each returned dict has the following keys:\\n      - module: the name of the module being imported\\n      - package: the name of the package that needs to be installed\\n    \\\"\\\"\\\"\\n    try:\\n        to_package_name = pyodide_js._module._import_name_to_package_name.to_py()\\n    except AttributeError:\\n        to_package_name = pyodide_js._api._import_name_to_package_name.to_py()\\n\\n    to_install: list[InstallEntry] = []\\n    for module in imports:\\n        try:\\n            importlib.import_module(module)\\n        except ModuleNotFoundError:\\n            to_install.append(\\n                dict(\\n                    module=module,\\n                    package=to_package_name.get(module, module),\\n                )\\n            )\\n    return to_install\\n\\n\\nasync def install_imports(\\n    source_code_or_imports: Union[str, list[str]],\\n    message_callback: Callable[\\n        [\\n            Literal[\\n                \\\"loading_all\\\",\\n                \\\"loaded_all\\\",\\n                \\\"loading_one\\\",\\n                \\\"loaded_one\\\",\\n                \\\"loading_micropip\\\",\\n                \\\"loaded_micropip\\\",\\n            ],\\n            Union[InstallEntry, list[InstallEntry]],\\n        ],\\n        None,\\n    ] = lambda event_type, data: None,\\n):\\n    \\\"\\\"\\\"\\n    Accepts a string of Python source code or a list of module names being imported.\\n    Installs any packages that need to be installed to import those modules,\\n    using micropip, which may also be installed if needed.\\n    If the package is not specially built for Pyodide, it must be available on PyPI\\n    as a pure Python wheel file.\\n    If the `message_callback` argument is provided, it will be called with an\\n    event type and data about the packages being installed.\\n    The event types start with `loading_` before installation, and `loaded_` after.\\n    The data is either a single dict representing the package being installed,\\n    or a list of all the packages being installed.\\n    The events are:\\n        - loading/loaded_all, with a list of all the packages being installed.\\n        - loading/loaded_one, with a dict for a single package.\\n        - loading/loaded_micropip, with a dict for the special micropip package.\\n    \\\"\\\"\\\"\\n    if isinstance(source_code_or_imports, str):\\n        try:\\n            imports: list[str] = find_imports(source_code_or_imports)\\n        except SyntaxError:\\n            return\\n    else:\\n        imports: list[str] = source_code_or_imports\\n\\n    to_install = find_imports_to_install(imports)\\n    if to_install:\\n        message_callback(\\\"loading_all\\\", to_install)\\n        try:\\n            import micropip  # noqa\\n        except ModuleNotFoundError:\\n            micropip_entry = dict(module=\\\"micropip\\\", package=\\\"micropip\\\")\\n            message_callback(\\\"loading_micropip\\\", micropip_entry)\\n            await pyodide_js.loadPackage(\\\"micropip\\\")\\n            import micropip  # noqa\\n\\n            message_callback(\\\"loaded_micropip\\\", micropip_entry)\\n\\n        for entry in to_install:\\n            message_callback(\\\"loading_one\\\", entry)\\n            await micropip.install(entry[\\\"package\\\"])\\n            message_callback(\\\"loaded_one\\\", entry)\\n        message_callback(\\\"loaded_all\\\", to_install)\\n\";","module.exports = require('./lib/retry');","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__272__;","module.exports = __WEBPACK_EXTERNAL_MODULE__422__;","module.exports = __WEBPACK_EXTERNAL_MODULE__28__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import retry from 'retry';\n\nconst networkErrorMsgs = new Set([\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari\n\t'Network request failed', // `cross-fetch`\n]);\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nconst isNetworkError = errorMessage => networkErrorMsgs.has(errorMessage);\n\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new Error(errorMessage)\n\t: new DOMException(errorMessage);\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\tonFailedAttempt() {},\n\t\t\tretries: 10,\n\t\t\t...options,\n\t\t};\n\n\t\tconst operation = retry.operation(options);\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tresolve(await input(attemptNumber));\n\t\t\t} catch (error) {\n\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\treject(new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error.originalError);\n\t\t\t\t} else if (error instanceof TypeError && !isNetworkError(error.message)) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait options.onFailedAttempt(error);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\treject(operation.mainError());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\toperation.stop();\n\t\t\t\tconst reason = options.signal.reason === undefined\n\t\t\t\t\t? getDOMException('The operation was aborted.')\n\t\t\t\t\t: options.signal.reason;\n\t\t\t\treject(reason instanceof Error ? reason : getDOMException(reason));\n\t\t\t}, {\n\t\t\t\tonce: true,\n\t\t\t});\n\t\t}\n\t});\n}\n","import pRetry from \"p-retry\";\nimport {SyncClient, syncExpose, SyncExtras} from \"comsync\";\nimport * as Comlink from \"comlink\";\nimport {loadPyodide, PyodideInterface, version as npmVersion} from \"pyodide\";\n\nconst pyodide_worker_runner_contents = require(\"!!raw-loader!./pyodide_worker_runner.py\")\n  .default;\n\nexport type PyodideLoader = () => Promise<PyodideInterface>;\nexport interface PackageOptions {\n  url: string; // URL to fetch the package from\n\n  // These arguments are passed to `pyodide.unpackArchive`\n  // (https://pyodide.org/en/stable/usage/api/js-api.html#pyodide.unpackArchive)\n  format: string; // By default the options are 'bztar', 'gztar', 'tar', 'zip', and 'wheel'\n  extractDir?: string; // Defaults to /tmp/\n}\n\n/**\n * Loads the Pyodide module from the official CDN as suggested in\n * https://pyodide.org/en/stable/usage/quickstart.html#setup.\n * To load a specific version, pass a string such as \"1.2.3\" as the argument.\n * By default, uses `pyodide.version`, i.e. the version you have installed from npm\n * as a peer dependency.\n */\nexport async function defaultPyodideLoader(version: string = npmVersion): Promise<PyodideInterface> {\n  const indexURL = `https://cdn.jsdelivr.net/pyodide/v${version}/full/`;\n  const result = await loadPyodide({indexURL});\n  if (result.version !== version) {\n    throw new Error(\n      `loadPyodide loaded version ${result.version} instead of ${version}`,\n    );\n  }\n  return result;\n}\n\n/**\n * Converts a version string to an array of numbers,\n * e.g. \"1.2.3\" -> [1, 2, 3]\n */\nexport function versionInfo(version: string): number[] {\n  return version.split(\".\").map(Number);\n}\n\n/**\n * Loads Pyodide in parallel to downloading an archive with your own code and dependencies,\n * which it then unpacks into the virtual filesystem ready for you to import.\n *\n * This helps you to work with Python code normally with several `.py` files\n * instead of a giant string passed to Pyodide's `runPython`.\n * It also lets you start up more quickly instead of waiting for Pyodide to load\n * before calling `loadPackage` or `micropip.install`.\n *\n * The archive should contain your own Python files and any Python dependencies.\n * A simple way to gather Python dependencies into a folder is with `pip install -t <folder>`.\n * The location where the archive is extracted will be added to `sys.path` so it can be imported immediately,\n * e.g. with [`pyodide.pyimport`](https://pyodide.org/en/stable/usage/api/js-api.html#pyodide.pyimport).\n * There should be no top-level folder in the archive containing everything else,\n * or that's what you'll have to import.\n *\n * If you don't use `loadPyodideAndPackage` and just load Pyodide yourself,\n * then we recommend passing the resulting module object to `initPyodide` for some other housekeeping.\n *\n * Loading of both Pyodide and the package is retried up to 3 times in case of network errors.\n *\n * The raw contents of the package are cached in memory to avoid re-downloading in case of\n * a fatal error which requires reloading Pyodide.\n *\n * @param packageOptions Object which describes how to load the package file, with the following keys:\n *    - `url`: URL to fetch the package from.\n *    - `format`: File format which determines how to extract the archive.\n *                By default the options are 'bztar', 'gztar', 'tar', 'zip', and 'wheel'.\n *    - `extractDir`: Directory to extract the archive into. Defaults to /tmp/.\n * @param pyodideLoader Optional function which takes no arguments and returns the Pyodide module as returned by the\n *    [`loadPyodide`](https://pyodide.org/en/stable/usage/api/js-api.html#globalThis.loadPyodide) function.\n *    Defaults to `defaultPyodideLoader`which uses the\n *    [official CDN](https://pyodide.org/en/stable/usage/quickstart.html#setup).\n */\nexport async function loadPyodideAndPackage(\n  packageOptions: PackageOptions,\n  pyodideLoader: PyodideLoader = defaultPyodideLoader,\n) : Promise<PyodideInterface> {\n  let {format, extractDir, url} = packageOptions;\n  extractDir = extractDir || \"/tmp/\";\n\n  let pyodide: PyodideInterface;\n  let packageBuffer: ArrayBuffer;\n  [pyodide, packageBuffer] = await Promise.all([\n    pRetry(() => pyodideLoader(), {retries: 3}),\n    pRetry(() => getPackageBuffer(url), {retries: 3}),\n  ]);\n\n  const vInfo = versionInfo(pyodide.version);\n  pyodide.unpackArchive(\n    packageBuffer,\n    format,\n    vInfo[0] === 0 && vInfo[1] <= 19 ? (extractDir as any) : {extractDir},\n  );\n\n  const sys = pyodide.pyimport(\"sys\");\n  sys.path.append(extractDir);\n\n  initPyodide(pyodide);\n\n  return pyodide;\n}\n\n/**\n * Initializes the given Pyodide module with some extra functionality:\n *   - `pyodide.registerComlink(Comlink)` makes `Comlink` (and thus `comsync` and the `PyodideClient`) work better.\n *   - Imports the `pyodide_worker_runner` Python module included with this library, which:\n *     - Immediately calls `sys.setrecursionlimit` so that deep recursion causes a Python `RecursionError`\n *       instead of a fatal JS `RangeError: Maximum call stack size exceeded`.\n *     - Provides the `install_imports` function which allows automatically installing imported modules, similar to\n *       [`loadPackagesFromImports`](https://pyodide.org/en/stable/usage/api/js-api.html#pyodide.loadPackagesFromImports)\n *       but also loads packages which are not built into Pyodide but can be installed with `micropip`,\n *       i.e. pure Python packages with wheels available on PyPI.\n */\nexport function initPyodide(pyodide: PyodideInterface) {\n  pyodide.registerComlink(Comlink);\n\n  const sys = pyodide.pyimport(\"sys\");\n  const pathlib = pyodide.pyimport(\"pathlib\");\n\n  const dirPath = \"/tmp/pyodide_worker_runner/\";\n  sys.path.append(dirPath);\n  pathlib.Path(dirPath).mkdir();\n  pathlib\n    .Path(dirPath + \"pyodide_worker_runner.py\")\n    .write_text(pyodide_worker_runner_contents);\n  pyodide.pyimport(\"pyodide_worker_runner\");\n}\n\nconst packageCache = new Map<string, ArrayBuffer>();\n\nasync function getPackageBuffer(url: string) {\n  if (packageCache.has(url)) {\n    console.log(\"Loaded package from cache\");\n    return packageCache.get(url);\n  }\n  console.log(\"Fetching package from \" + url.slice(0, 100) + \"...\");\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(\n      `Request for package failed with status ${response.status}: ${response.statusText}`,\n    );\n  }\n  const result = await response.arrayBuffer();\n  console.log(\"Fetched package\");\n  packageCache.set(url, result);\n  return result;\n}\n\n/**\n * See the description of output parts in\n * https://github.com/alexmojaki/python_runner#callback-events\n */\nexport interface OutputPart {\n  type: string;\n  text: string;\n  [key: string]: unknown;\n}\n\nexport interface RunnerCallbacks {\n  input?: (prompt: string) => void;\n  output: (parts: OutputPart[]) => unknown;\n  other?: (type: string, data: unknown) => unknown;\n}\n\n/**\n * Construct a callback function which can be passed to `python_runner` to handle events.\n * See https://github.com/alexmojaki/python_runner#callback-events\n *\n * @param comsyncExtras\n *    In a web worker script, you need to pass a function to `pyodideExpose` from this library.\n *    That function will be passed `extras` as its first argument which can then be used here.\n *    `extras` is expected to contain a `channel` created by the `makeChannel` function from\n *    the [`sync-message`](https://github.com/alexmojaki/sync-message) library\n *    which was then passed to `PyodideClient` in the main thread.\n *    This enables synchronous communication between the main thread and the worker,\n *    which is used by the callback to handle `input` and `sleep` events properly.\n *    See https://github.com/alexmojaki/pyodide-worker-runner#comsync-integration for more info.\n * @param callbacks\n *    An object containing callback functions to handle the different event types.\n *      - `output`: Required. Called with an array of output parts,\n *         e.g. `[{type: \"stdout\", text: \"Hello world\"}]`.\n *         Use this to tell your UI to display the output.\n *      - `input`: Optional. Called when the Python code reads from `sys.stdin`, e.g. with `input()`.\n *         Use this to tell your UI to wait for the user to enter some text.\n *         The entered text should be passed to `PyodideClient.writeMessage()` in the main thread,\n *         and will be returned synchronously by this function to the Python code.\n *         When the Python code calls `input(prompt)`, the string `prompt` is passed to this callback.\n *         Two types of output part will also be passed to the `output` callback:\n *             - `input_prompt`: the prompt passed to the `input()` function.\n *               Using this output part may be a better way to display the prompt in the UI\n *               than the argument of the `input` callback, but the `input` callback is still needed\n *               even if it doesn't display the prompt.\n *              - `input`: the user's input passed to stdin.\n *                Not actually 'output', but included as an output part\n *                because it's typically shown in regular Python consoles.\n *      - `other`: Optional. Called for all other event types\n *        (except `sleep` which is handled directly by `makeRunnerCallback`).\n *        The actual event type is passed as the first argument.\n */\nexport function makeRunnerCallback(\n  comsyncExtras: SyncExtras,\n  callbacks: RunnerCallbacks,\n) {\n  return function (type: string, data: any) {\n    if (data.toJs) {\n      data = data.toJs({dict_converter: Object.fromEntries});\n    }\n\n    if (type === \"input\") {\n      callbacks.input && callbacks.input(data.prompt);\n      return comsyncExtras.readMessage() + \"\\n\";\n    } else if (type === \"sleep\") {\n      comsyncExtras.syncSleep(data.seconds * 1000);\n    } else if (type === \"output\") {\n      return callbacks.output(data.parts);\n    } else {\n      return callbacks.other(type, data);\n    }\n  };\n}\n\nexport interface PyodideExtras extends SyncExtras {\n  interruptBuffer: Int32Array | null;\n}\n\n/**\n * Call this in your web worker code with a function `func`\n * to allow it to be called from the main thread by `PyodideClient.call`.\n *\n * `func` will be called with an object `extras` of type `PyodideExtras` as its first argument.\n * The other arguments are those passed to `PyodideClient.call`,\n * and the return value is passed back to the main thread and returned from `PyodideClient.call`.\n *\n * `func` will be wrapped into a new function which is returned here.\n * The returned function should be passed to `Comlink.expose`, possibly as part of a larger object.\n *\n * For example, the worker code may look something like this:\n *\n *     Comlink.expose({\n *       myRunCode: pyodideExpose((extras, code) => {\n *         pyodide.runCode(code);\n *       }),\n *     });\n *\n * and the main thread code may look something like this:\n *\n *    await client.call(client.workerProxy.myRunCode, \"print('Hello world')\");\n *\n * It's recommended to pass `extras` to `makeRunnerCallback` and then pass the resulting callback\n * to a `python_runner.PyodideRunner` instead of calling `pyodide.runCode` directly.\n *\n * If possible, `extras.interruptBuffer` will be a `SharedArrayBuffer` which can be used like this:\n *\n *     if (extras.interruptBuffer) {\n *       pyodide.setInterruptBuffer(extras.interruptBuffer);\n *     }\n *\n * This will allow the main thread to call `PyodideClient.interrupt()`\n * to raise `KeyboardInterrupt` in Python code running in Pyodide in the worker thread.\n * `setInterruptBuffer` isn't called automatically so that you can choose the correct place to call it,\n * after running any Python code that musn't be interrupted.\n */\nexport function pyodideExpose<T extends any[], R>(\n  func: (extras: PyodideExtras, ...args: T) => R,\n) {\n  return syncExpose(async function (\n    comsyncExtras: SyncExtras,\n    interruptBuffer: Int32Array | null,\n    ...args: T\n  ): Promise<R> {\n    return func({...comsyncExtras, interruptBuffer}, ...args);\n  });\n}\n\n/**\n * This class should be used in the main browser thread\n * to call functions exposed with `pyodideExpose` and `Comlink.expose` in a web worker.\n * See https://github.com/alexmojaki/comsync to learn how to use the base class `SyncClient`.\n * What this class adds is making it easier to interrupt Python code running in Pyodide in the worker.\n * Specifically, if `SharedArrayBuffer` is available, then `PyodideClient.call` will pass a buffer\n * so that the function passed to `pyodideExpose` can call `pyodide.setInterruptBuffer(extras.interruptBuffer)`\n * to enable interruption. Then `PyodideClient.interrupt()` will use the buffer.\n * Otherwise, `PyodideClient.interrupt()` will likely restart the web worker entirely, which is more disruptive.\n */\nexport class PyodideClient<T = any> extends SyncClient<T> {\n  async call(proxyMethod: any, ...args: any[]) {\n    let interruptBuffer: Int32Array | null = null;\n    if (typeof SharedArrayBuffer !== \"undefined\") {\n      interruptBuffer = new Int32Array(\n        new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 1),\n      );\n      this.interrupter = () => {\n        interruptBuffer[0] = 2;\n      };\n    }\n\n    return super.call(proxyMethod, interruptBuffer, ...args);\n  }\n}\n\n/**\n * This class handles automatically reloading Pyodide from scratch when a fatal error occurs.\n * The constructor accepts a 'loader' function which should return a promise that resolves to a Pyodide module.\n * We recommend a function which calls `loadPyodideAndPackage`.\n * The loader function will be called immediately on construction.\n *\n * Code that uses the Pyodide module should be wrapped in a `withPyodide` call, e.g:\n *\n *    await pyodideFatalErrorReloader.withPyodide(async (pyodide) => {\n *      pyodide.runCode(...);\n *    });\n *\n * If a fatal error occurs, the loader function will be called again immediately to reload Pyodide in the background,\n * while the error is rethrown for you to handle.\n * The next call to `withPyodide` will then be able to use the new Pyodide instance.\n *\n * In general, `withPyodide` will wait for the loader function to complete, and will throw any errors it throws.\n */\nexport class PyodideFatalErrorReloader {\n  private pyodidePromise: Promise<PyodideInterface>;\n\n  constructor(private readonly loader: PyodideLoader) {\n    this.pyodidePromise = loader();\n  }\n\n  public async withPyodide<T>(\n    fn: (pyodide: PyodideInterface) => Promise<T>,\n  ): Promise<T> {\n    const pyodide = await this.pyodidePromise;\n    try {\n      return await fn(pyodide);\n    } catch (e) {\n      if (e.pyodide_fatal_error) {\n        this.pyodidePromise = this.loader();\n      }\n      throw e;\n    }\n  }\n}\n","module.exports = eval(\"\\\"use strict\\\";var loadPyodide=(()=>{var ne=Object.create;var O=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var ie=Object.getPrototypeOf,ae=Object.prototype.hasOwnProperty;var c=(e,t)=>O(e,\\\"name\\\",{value:t,configurable:!0}),p=(e=>typeof require<\\\"u\\\"?require:typeof Proxy<\\\"u\\\"?new Proxy(e,{get:(t,o)=>(typeof require<\\\"u\\\"?require:t)[o]}):e)(function(e){if(typeof require<\\\"u\\\")return require.apply(this,arguments);throw new Error('Dynamic require of \\\"'+e+'\\\" is not supported')});var se=(e,t)=>{for(var o in t)O(e,o,{get:t[o],enumerable:!0})},$=(e,t,o,r)=>{if(t&&typeof t==\\\"object\\\"||typeof t==\\\"function\\\")for(let a of oe(t))!ae.call(e,a)&&a!==o&&O(e,a,{get:()=>t[a],enumerable:!(r=re(t,a))||r.enumerable});return e};var b=(e,t,o)=>(o=e!=null?ne(ie(e)):{},$(t||!e||!e.__esModule?O(o,\\\"default\\\",{value:e,enumerable:!0}):o,e)),ce=e=>$(O({},\\\"__esModule\\\",{value:!0}),e);var Oe={};se(Oe,{loadPyodide:()=>B,version:()=>k});function le(e){return!isNaN(parseFloat(e))&&isFinite(e)}c(le,\\\"_isNumber\\\");function w(e){return e.charAt(0).toUpperCase()+e.substring(1)}c(w,\\\"_capitalize\\\");function L(e){return function(){return this[e]}}c(L,\\\"_getter\\\");var _=[\\\"isConstructor\\\",\\\"isEval\\\",\\\"isNative\\\",\\\"isToplevel\\\"],F=[\\\"columnNumber\\\",\\\"lineNumber\\\"],R=[\\\"fileName\\\",\\\"functionName\\\",\\\"source\\\"],de=[\\\"args\\\"],ue=[\\\"evalOrigin\\\"],x=_.concat(F,R,de,ue);function g(e){if(e)for(var t=0;t<x.length;t++)e[x[t]]!==void 0&&this[\\\"set\\\"+w(x[t])](e[x[t]])}c(g,\\\"StackFrame\\\");g.prototype={getArgs:function(){return this.args},setArgs:function(e){if(Object.prototype.toString.call(e)!==\\\"[object Array]\\\")throw new TypeError(\\\"Args must be an Array\\\");this.args=e},getEvalOrigin:function(){return this.evalOrigin},setEvalOrigin:function(e){if(e instanceof g)this.evalOrigin=e;else if(e instanceof Object)this.evalOrigin=new g(e);else throw new TypeError(\\\"Eval Origin must be an Object or StackFrame\\\")},toString:function(){var e=this.getFileName()||\\\"\\\",t=this.getLineNumber()||\\\"\\\",o=this.getColumnNumber()||\\\"\\\",r=this.getFunctionName()||\\\"\\\";return this.getIsEval()?e?\\\"[eval] (\\\"+e+\\\":\\\"+t+\\\":\\\"+o+\\\")\\\":\\\"[eval]:\\\"+t+\\\":\\\"+o:r?r+\\\" (\\\"+e+\\\":\\\"+t+\\\":\\\"+o+\\\")\\\":e+\\\":\\\"+t+\\\":\\\"+o}};g.fromString=c(function(t){var o=t.indexOf(\\\"(\\\"),r=t.lastIndexOf(\\\")\\\"),a=t.substring(0,o),n=t.substring(o+1,r).split(\\\",\\\"),i=t.substring(r+1);if(i.indexOf(\\\"@\\\")===0)var s=/@(.+?)(?::(\\\\d+))?(?::(\\\\d+))?$/.exec(i,\\\"\\\"),l=s[1],d=s[2],u=s[3];return new g({functionName:a,args:n||void 0,fileName:l,lineNumber:d||void 0,columnNumber:u||void 0})},\\\"StackFrame$$fromString\\\");for(h=0;h<_.length;h++)g.prototype[\\\"get\\\"+w(_[h])]=L(_[h]),g.prototype[\\\"set\\\"+w(_[h])]=function(e){return function(t){this[e]=!!t}}(_[h]);var h;for(E=0;E<F.length;E++)g.prototype[\\\"get\\\"+w(F[E])]=L(F[E]),g.prototype[\\\"set\\\"+w(F[E])]=function(e){return function(t){if(!le(t))throw new TypeError(e+\\\" must be a Number\\\");this[e]=Number(t)}}(F[E]);var E;for(S=0;S<R.length;S++)g.prototype[\\\"get\\\"+w(R[S])]=L(R[S]),g.prototype[\\\"set\\\"+w(R[S])]=function(e){return function(t){this[e]=String(t)}}(R[S]);var S,A=g;function fe(){var e=/^\\\\s*at .*(\\\\S+:\\\\d+|\\\\(native\\\\))/m,t=/^(eval@)?(\\\\[native code])?$/;return{parse:c(function(r){if(r.stack&&r.stack.match(e))return this.parseV8OrIE(r);if(r.stack)return this.parseFFOrSafari(r);throw new Error(\\\"Cannot parse given Error object\\\")},\\\"ErrorStackParser$$parse\\\"),extractLocation:c(function(r){if(r.indexOf(\\\":\\\")===-1)return[r];var a=/(.+?)(?::(\\\\d+))?(?::(\\\\d+))?$/,n=a.exec(r.replace(/[()]/g,\\\"\\\"));return[n[1],n[2]||void 0,n[3]||void 0]},\\\"ErrorStackParser$$extractLocation\\\"),parseV8OrIE:c(function(r){var a=r.stack.split(`\\n`).filter(function(n){return!!n.match(e)},this);return a.map(function(n){n.indexOf(\\\"(eval \\\")>-1&&(n=n.replace(/eval code/g,\\\"eval\\\").replace(/(\\\\(eval at [^()]*)|(,.*$)/g,\\\"\\\"));var i=n.replace(/^\\\\s+/,\\\"\\\").replace(/\\\\(eval code/g,\\\"(\\\").replace(/^.*?\\\\s+/,\\\"\\\"),s=i.match(/ (\\\\(.+\\\\)$)/);i=s?i.replace(s[0],\\\"\\\"):i;var l=this.extractLocation(s?s[1]:i),d=s&&i||void 0,u=[\\\"eval\\\",\\\"<anonymous>\\\"].indexOf(l[0])>-1?void 0:l[0];return new A({functionName:d,fileName:u,lineNumber:l[1],columnNumber:l[2],source:n})},this)},\\\"ErrorStackParser$$parseV8OrIE\\\"),parseFFOrSafari:c(function(r){var a=r.stack.split(`\\n`).filter(function(n){return!n.match(t)},this);return a.map(function(n){if(n.indexOf(\\\" > eval\\\")>-1&&(n=n.replace(/ line (\\\\d+)(?: > eval line \\\\d+)* > eval:\\\\d+:\\\\d+/g,\\\":$1\\\")),n.indexOf(\\\"@\\\")===-1&&n.indexOf(\\\":\\\")===-1)return new A({functionName:n});var i=/((.*\\\".+\\\"[^@]*)?[^@]*)(?:@)/,s=n.match(i),l=s&&s[1]?s[1]:void 0,d=this.extractLocation(n.replace(i,\\\"\\\"));return new A({functionName:l,fileName:d[0],lineNumber:d[1],columnNumber:d[2],source:n})},this)},\\\"ErrorStackParser$$parseFFOrSafari\\\")}}c(fe,\\\"ErrorStackParser\\\");var me=new fe;var j=me;var y=typeof process==\\\"object\\\"&&typeof process.versions==\\\"object\\\"&&typeof process.versions.node==\\\"string\\\"&&!process.browser,T=y&&typeof module<\\\"u\\\"&&typeof module.exports<\\\"u\\\"&&typeof p<\\\"u\\\"&&typeof __dirname<\\\"u\\\",H=y&&!T,Le=typeof globalThis.Bun<\\\"u\\\",pe=typeof Deno<\\\"u\\\",V=!y&&!pe,z=V&&typeof window==\\\"object\\\"&&typeof document==\\\"object\\\"&&typeof document.createElement==\\\"function\\\"&&\\\"sessionStorage\\\"in window&&typeof importScripts!=\\\"function\\\",q=V&&typeof importScripts==\\\"function\\\"&&typeof self==\\\"object\\\",Te=typeof navigator==\\\"object\\\"&&typeof navigator.userAgent==\\\"string\\\"&&navigator.userAgent.indexOf(\\\"Chrome\\\")==-1&&navigator.userAgent.indexOf(\\\"Safari\\\")>-1;var K,U,Y,J,C;async function M(){if(!y||(K=(await import(/* webpackIgnore */\\\"node:url\\\")).default,J=await import(/* webpackIgnore */\\\"node:fs\\\"),C=await import(/* webpackIgnore */\\\"node:fs/promises\\\"),Y=(await import(/* webpackIgnore */\\\"node:vm\\\")).default,U=await import(/* webpackIgnore */\\\"node:path\\\"),W=U.sep,typeof p<\\\"u\\\"))return;let e=J,t=await import(/* webpackIgnore */\\\"node:crypto\\\"),o=await import(/* webpackIgnore */\\\"ws\\\"),r=await import(/* webpackIgnore */\\\"node:child_process\\\"),a={fs:e,crypto:t,ws:o,child_process:r};({});}c(M,\\\"initNodeModules\\\");function ge(e,t){return U.resolve(t||\\\".\\\",e)}c(ge,\\\"node_resolvePath\\\");function ye(e,t){return t===void 0&&(t=location),new URL(e,t).toString()}c(ye,\\\"browser_resolvePath\\\");var D;y?D=ge:D=ye;var W;y||(W=\\\"/\\\");function be(e,t){return e.startsWith(\\\"file://\\\")&&(e=e.slice(7)),e.includes(\\\"://\\\")?{response:fetch(e)}:{binary:C.readFile(e).then(o=>new Uint8Array(o.buffer,o.byteOffset,o.byteLength))}}c(be,\\\"node_getBinaryResponse\\\");function ve(e,t){let o=new URL(e,location);return{response:fetch(o,t?{integrity:t}:{})}}c(ve,\\\"browser_getBinaryResponse\\\");var P;y?P=be:P=ve;async function G(e,t){let{response:o,binary:r}=P(e,t);if(r)return r;let a=await o;if(!a.ok)throw new Error(`Failed to load '${e}': request failed.`);return new Uint8Array(await a.arrayBuffer())}c(G,\\\"loadBinaryFile\\\");var I;if(z)I=c(async e=>await import(/* webpackIgnore */e),\\\"loadScript\\\");else if(q)I=c(async e=>{try{globalThis.importScripts(e)}catch(t){if(t instanceof TypeError)await import(/* webpackIgnore */e);else throw t}},\\\"loadScript\\\");else if(y)I=he;else throw new Error(\\\"Cannot determine runtime environment\\\");async function he(e){e.startsWith(\\\"file://\\\")&&(e=e.slice(7)),e.includes(\\\"://\\\")?Y.runInThisContext(await(await fetch(e)).text()):await import(/* webpackIgnore */K.pathToFileURL(e).href)}c(he,\\\"nodeLoadScript\\\");async function X(e){if(y){await M();let t=await C.readFile(e,{encoding:\\\"utf8\\\"});return JSON.parse(t)}else return await(await fetch(e)).json()}c(X,\\\"loadLockFile\\\");async function Q(){if(T)return __dirname;let e;try{throw new Error}catch(r){e=r}let t=j.parse(e)[0].fileName;if(y&&!t.startsWith(\\\"file://\\\")&&(t=`file://${t}`),H){let r=await import(/* webpackIgnore */\\\"node:path\\\");return(await import(/* webpackIgnore */\\\"node:url\\\")).fileURLToPath(r.dirname(t))}let o=t.lastIndexOf(W);if(o===-1)throw new Error(\\\"Could not extract indexURL path from pyodide module location\\\");return t.slice(0,o)}c(Q,\\\"calculateDirname\\\");function Z(e){let t=e.FS,o=e.FS.filesystems.MEMFS,r=e.PATH,a={DIR_MODE:16895,FILE_MODE:33279,mount:function(n){if(!n.opts.fileSystemHandle)throw new Error(\\\"opts.fileSystemHandle is required\\\");return o.mount.apply(null,arguments)},syncfs:async(n,i,s)=>{try{let l=a.getLocalSet(n),d=await a.getRemoteSet(n),u=i?d:l,m=i?l:d;await a.reconcile(n,u,m),s(null)}catch(l){s(l)}},getLocalSet:n=>{let i=Object.create(null);function s(u){return u!==\\\".\\\"&&u!==\\\"..\\\"}c(s,\\\"isRealDir\\\");function l(u){return m=>r.join2(u,m)}c(l,\\\"toAbsolute\\\");let d=t.readdir(n.mountpoint).filter(s).map(l(n.mountpoint));for(;d.length;){let u=d.pop(),m=t.stat(u);t.isDir(m.mode)&&d.push.apply(d,t.readdir(u).filter(s).map(l(u))),i[u]={timestamp:m.mtime,mode:m.mode}}return{type:\\\"local\\\",entries:i}},getRemoteSet:async n=>{let i=Object.create(null),s=await Ee(n.opts.fileSystemHandle);for(let[l,d]of s)l!==\\\".\\\"&&(i[r.join2(n.mountpoint,l)]={timestamp:d.kind===\\\"file\\\"?(await d.getFile()).lastModifiedDate:new Date,mode:d.kind===\\\"file\\\"?a.FILE_MODE:a.DIR_MODE});return{type:\\\"remote\\\",entries:i,handles:s}},loadLocalEntry:n=>{let s=t.lookupPath(n).node,l=t.stat(n);if(t.isDir(l.mode))return{timestamp:l.mtime,mode:l.mode};if(t.isFile(l.mode))return s.contents=o.getFileDataAsTypedArray(s),{timestamp:l.mtime,mode:l.mode,contents:s.contents};throw new Error(\\\"node type not supported\\\")},storeLocalEntry:(n,i)=>{if(t.isDir(i.mode))t.mkdirTree(n,i.mode);else if(t.isFile(i.mode))t.writeFile(n,i.contents,{canOwn:!0});else throw new Error(\\\"node type not supported\\\");t.chmod(n,i.mode),t.utime(n,i.timestamp,i.timestamp)},removeLocalEntry:n=>{var i=t.stat(n);t.isDir(i.mode)?t.rmdir(n):t.isFile(i.mode)&&t.unlink(n)},loadRemoteEntry:async n=>{if(n.kind===\\\"file\\\"){let i=await n.getFile();return{contents:new Uint8Array(await i.arrayBuffer()),mode:a.FILE_MODE,timestamp:i.lastModifiedDate}}else{if(n.kind===\\\"directory\\\")return{mode:a.DIR_MODE,timestamp:new Date};throw new Error(\\\"unknown kind: \\\"+n.kind)}},storeRemoteEntry:async(n,i,s)=>{let l=n.get(r.dirname(i)),d=t.isFile(s.mode)?await l.getFileHandle(r.basename(i),{create:!0}):await l.getDirectoryHandle(r.basename(i),{create:!0});if(d.kind===\\\"file\\\"){let u=await d.createWritable();await u.write(s.contents),await u.close()}n.set(i,d)},removeRemoteEntry:async(n,i)=>{await n.get(r.dirname(i)).removeEntry(r.basename(i)),n.delete(i)},reconcile:async(n,i,s)=>{let l=0,d=[];Object.keys(i.entries).forEach(function(f){let v=i.entries[f],N=s.entries[f];(!N||t.isFile(v.mode)&&v.timestamp.getTime()>N.timestamp.getTime())&&(d.push(f),l++)}),d.sort();let u=[];if(Object.keys(s.entries).forEach(function(f){i.entries[f]||(u.push(f),l++)}),u.sort().reverse(),!l)return;let m=i.type===\\\"remote\\\"?i.handles:s.handles;for(let f of d){let v=r.normalize(f.replace(n.mountpoint,\\\"/\\\")).substring(1);if(s.type===\\\"local\\\"){let N=m.get(v),te=await a.loadRemoteEntry(N);a.storeLocalEntry(f,te)}else{let N=a.loadLocalEntry(f);await a.storeRemoteEntry(m,v,N)}}for(let f of u)if(s.type===\\\"local\\\")a.removeLocalEntry(f);else{let v=r.normalize(f.replace(n.mountpoint,\\\"/\\\")).substring(1);await a.removeRemoteEntry(m,v)}}};e.FS.filesystems.NATIVEFS_ASYNC=a}c(Z,\\\"initializeNativeFS\\\");var Ee=c(async e=>{let t=[];async function o(a){for await(let n of a.values())t.push(n),n.kind===\\\"directory\\\"&&await o(n)}c(o,\\\"collect\\\"),await o(e);let r=new Map;r.set(\\\".\\\",e);for(let a of t){let n=(await e.resolve(a)).join(\\\"/\\\");r.set(n,a)}return r},\\\"getFsHandles\\\");function ee(e){let t={noImageDecoding:!0,noAudioDecoding:!0,noWasmDecoding:!1,preRun:Fe(e),quit(o,r){throw t.exited={status:o,toThrow:r},r},print:e.stdout,printErr:e.stderr,arguments:e.args,API:{config:e},locateFile:o=>e.indexURL+o,instantiateWasm:Re(e.indexURL)};return t}c(ee,\\\"createSettings\\\");function Se(e){return function(t){let o=\\\"/\\\";try{t.FS.mkdirTree(e)}catch(r){console.error(`Error occurred while making a home directory '${e}':`),console.error(r),console.error(`Using '${o}' for a home directory instead`),e=o}t.FS.chdir(e)}}c(Se,\\\"createHomeDirectory\\\");function we(e){return function(t){Object.assign(t.ENV,e)}}c(we,\\\"setEnvironment\\\");function Ne(e){return t=>{for(let o of e)t.FS.mkdirTree(o),t.FS.mount(t.FS.filesystems.NODEFS,{root:o},o)}}c(Ne,\\\"mountLocalDirectories\\\");function _e(e){let t=G(e);return o=>{let r=o._py_version_major(),a=o._py_version_minor();o.FS.mkdirTree(\\\"/lib\\\"),o.FS.mkdirTree(`/lib/python${r}.${a}/site-packages`),o.addRunDependency(\\\"install-stdlib\\\"),t.then(n=>{o.FS.writeFile(`/lib/python${r}${a}.zip`,n)}).catch(n=>{console.error(\\\"Error occurred while installing the standard library:\\\"),console.error(n)}).finally(()=>{o.removeRunDependency(\\\"install-stdlib\\\")})}}c(_e,\\\"installStdlib\\\");function Fe(e){let t;return e.stdLibURL!=null?t=e.stdLibURL:t=e.indexURL+\\\"python_stdlib.zip\\\",[_e(t),Se(e.env.HOME),we(e.env),Ne(e._node_mounts),Z]}c(Fe,\\\"getFileSystemInitializationFuncs\\\");function Re(e){let{binary:t,response:o}=P(e+\\\"pyodide.asm.wasm\\\");return function(r,a){return async function(){try{let n;o?n=await WebAssembly.instantiateStreaming(o,r):n=await WebAssembly.instantiate(await t,r);let{instance:i,module:s}=n;typeof WasmOffsetConverter<\\\"u\\\"&&(wasmOffsetConverter=new WasmOffsetConverter(wasmBinary,s)),a(i,s)}catch(n){console.warn(\\\"wasm instantiation failed!\\\"),console.warn(n)}}(),{}}}c(Re,\\\"getInstantiateWasmFunc\\\");var k=\\\"0.26.4\\\";async function B(e={}){var u,m;await M();let t=e.indexURL||await Q();t=D(t),t.endsWith(\\\"/\\\")||(t+=\\\"/\\\"),e.indexURL=t;let o={fullStdLib:!1,jsglobals:globalThis,stdin:globalThis.prompt?globalThis.prompt:void 0,lockFileURL:t+\\\"pyodide-lock.json\\\",args:[],_node_mounts:[],env:{},packageCacheDir:t,packages:[],enableRunUntilComplete:!1,checkAPIVersion:!0},r=Object.assign(o,e);(u=r.env).HOME??(u.HOME=\\\"/home/pyodide\\\"),(m=r.env).PYTHONINSPECT??(m.PYTHONINSPECT=\\\"1\\\");let a=ee(r),n=a.API;if(n.lockFilePromise=X(r.lockFileURL),typeof _createPyodideModule!=\\\"function\\\"){let f=`${r.indexURL}pyodide.asm.js`;await I(f)}let i;if(e._loadSnapshot){let f=await e._loadSnapshot;ArrayBuffer.isView(f)?i=f:i=new Uint8Array(f),a.noInitialRun=!0,a.INITIAL_MEMORY=i.length}let s=await _createPyodideModule(a);if(a.exited)throw a.exited.toThrow;if(e.pyproxyToStringRepr&&n.setPyProxyToStringMethod(!0),n.version!==k&&r.checkAPIVersion)throw new Error(`Pyodide version does not match: '${k}' <==> '${n.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);s.locateFile=f=>{throw new Error(\\\"Didn't expect to load any more file_packager files!\\\")};let l;i&&(l=n.restoreSnapshot(i));let d=n.finalizeBootstrap(l);return n.sys.path.insert(0,n.config.env.HOME),d.version.includes(\\\"dev\\\")||n.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${d.version}/full/`),n._pyodide.set_excepthook(),await n.packageIndexReady,n.initializeStreams(r.stdin,r.stdout,r.stderr),d}c(B,\\\"loadPyodide\\\");({});return ce(Oe);})();\\ntry{Object.assign(exports,loadPyodide)}catch(_){}\\n({});\\nmodule.exports = {loadPyodide: loadPyodide.loadPyodide, version: loadPyodide.version};\\n//# sourceMappingURL=pyodide.js.map\\n\");\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"syncMessage\"] = factory();\n\telse\n\t\troot[\"syncMessage\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const BASE_URL_SUFFIX = \"__SyncMessageServiceWorkerInput__\";\nconst VERSION = \"__sync-message-v2__\";\n\ninterface ServiceWorkerReadRequest {\n  messageId: string;\n  timeout: number;\n}\n\ninterface ServiceWorkerWriteRequest {\n  messageId: string;\n  message: string;\n}\n\ninterface ServiceWorkerResponse {\n  message: any;\n  version: string;\n}\n\n/**\n * Checks whether the given request is meant to be intercepted by the sync-message serviceWorkerFetchListener.\n */\nexport function isServiceWorkerRequest(request: FetchEvent | string): boolean {\n  if (typeof request !== \"string\") {\n    request = request.request.url;\n  }\n  return request.includes(BASE_URL_SUFFIX);\n}\n\n/**\n * Returns a function that can respond to fetch events in a service worker event listener.\n * The function returns true if the request came from this library and it responded.\n * Call `serviceWorkerFetchListener` and reuse the returned function as it manages internal state.\n */\nexport function serviceWorkerFetchListener(): (e: FetchEvent) => boolean {\n  const earlyMessages: {[messageId: string]: any} = {};\n  const resolvers: {[messageId: string]: (r: Response) => void} = {};\n\n  return (e: FetchEvent): boolean => {\n    const {url} = e.request;\n    if (!isServiceWorkerRequest(url)) {\n      return false;\n    }\n\n    async function respond(): Promise<Response> {\n      function success(message: any) {\n        const response: ServiceWorkerResponse = {message, version: VERSION};\n        return new Response(JSON.stringify(response), {status: 200});\n      }\n\n      if (url.endsWith(\"/read\")) {\n        const {\n          messageId,\n          timeout,\n        }: ServiceWorkerReadRequest = await e.request.json();\n        const data = earlyMessages[messageId];\n        if (data) {\n          delete earlyMessages[messageId];\n          return success(data);\n        } else {\n          return await new Promise((resolver) => {\n            resolvers[messageId] = resolver;\n\n            function callback() {\n              delete resolvers[messageId];\n              resolver(new Response(\"\", {status: 408})); // timeout\n            }\n\n            setTimeout(callback, timeout);\n          });\n        }\n      } else if (url.endsWith(\"/write\")) {\n        const {\n          message,\n          messageId,\n        }: ServiceWorkerWriteRequest = await e.request.json();\n        const resolver = resolvers[messageId];\n        if (resolver) {\n          resolver(success(message));\n          delete resolvers[messageId];\n        } else {\n          earlyMessages[messageId] = message;\n        }\n        return success({early: !resolver});\n      } else if (url.endsWith(\"/version\")) {\n        return new Response(VERSION, {status: 200});\n      }\n    }\n\n    e.respondWith(respond());\n    return true;\n  };\n}\n\n/**\n * Convenience function that allows writing `await asyncSleep(1000)`\n * to wait one second before continuing in an async function.\n */\nexport function asyncSleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Options for making an atomics type channel.\n */\nexport interface AtomicsChannelOptions {\n  // The number of bytes to allocate for the `SharedArrayBuffer`.\n  // Defaults to 128KiB.\n  // `writeMessage` will throw an error if the message is larger than the buffer size.\n  bufferSize?: number;\n}\n\n/**\n * Options for making a serviceWorker type channel.\n */\nexport interface ServiceWorkerChannelOptions {\n  // a string representing the prefix of a path/URL, defaulting to `\"/\"`.\n  // Both `readMessage` and `writeMessage` will make requests that start with this value\n  // so make sure that your service worker is controlling the page and can intercept those requests.\n  // The `scope` property of the registration object returned by `navigator.serviceWorker.register` should work.\n  scope?: string;\n\n  // number of milliseconds representing a grace period for the service worker to start up.\n  // If requests made by `readMessage` and `writeMessage` fail,\n  // they will be retried until this timeout is exceeded,\n  // at which point they will throw an error.\n  timeout?: number;\n}\n\ninterface AtomicsChannel {\n  type: \"atomics\";\n  data: Uint8Array;\n  meta: Int32Array;\n}\n\ninterface ServiceWorkerChannel {\n  type: \"serviceWorker\";\n  baseUrl: string;\n  timeout: number;\n}\n\nexport class ServiceWorkerError extends Error {\n  // To avoid having to use instanceof\n  public readonly type = \"ServiceWorkerError\";\n\n  constructor(public url: string, public status: number) {\n    super(\n      `Received status ${status} from ${url}. Ensure the service worker is registered and active.`,\n    );\n    // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.\n    Object.setPrototypeOf(this, ServiceWorkerError.prototype);\n  }\n}\n\nexport type Channel = AtomicsChannel | ServiceWorkerChannel;\n\nexport function writeMessageAtomics(channel: AtomicsChannel, message: any) {\n  const encoder = new TextEncoder();\n  const bytes = encoder.encode(JSON.stringify(message));\n  const {data, meta} = channel;\n  if (bytes.length > data.length) {\n    throw new Error(\n      \"Message is too big, increase bufferSize when making channel.\",\n    );\n  }\n  data.set(bytes, 0);\n  Atomics.store(meta, 0, bytes.length);\n  Atomics.store(meta, 1, 1);\n  Atomics.notify(meta, 1);\n}\n\nexport async function writeMessageServiceWorker(\n  channel: ServiceWorkerChannel,\n  message: any,\n  messageId: string,\n) {\n  await navigator.serviceWorker.ready;\n  const url = channel.baseUrl + \"/write\";\n  const startTime = Date.now();\n  while (true) {\n    const request: ServiceWorkerWriteRequest = {message, messageId};\n    const response = await fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(request),\n    });\n    if (\n      response.status === 200 &&\n      (await response.json()).version === VERSION\n    ) {\n      return;\n    }\n    if (Date.now() - startTime < channel.timeout) {\n      await asyncSleep(100);\n      continue;\n    }\n    throw new ServiceWorkerError(url, response.status);\n  }\n}\n\n/**\n * Call this in the browser's main UI thread\n * to send a message to the worker reading from the channel with `readMessage`.\n *\n * @param channel a non-null object returned by `makeChannel`, `makeAtomicsChannel`, or `makeServiceWorkerChannel`.\n * @param message any object that can be safely passed to `JSON.stringify` and then decoded with `JSON.parse`.\n * @param messageId a unique string identifying the message that the worker is waiting for.\n *                  Currently only used by service worker channels.\n */\nexport async function writeMessage(\n  channel: Channel,\n  message: any,\n  messageId: string,\n) {\n  if (channel.type === \"atomics\") {\n    writeMessageAtomics(channel, message);\n  } else {\n    await writeMessageServiceWorker(channel, message, messageId);\n  }\n}\n\n/**\n * Accepts one optional argument `options` with optional keys for configuring the different types of channel.\n * See the types `AtomicsChannelOptions` and `ServiceWorkerChannelOptions` for more info.\n *\n * If `SharedArrayBuffer` is available, `makeChannel` will use it to create an `atomics` type channel.\n * Otherwise, if `navigator.serviceWorker` is available, it will create a `serviceWorker` type channel,\n * but registering the service worker is up to you.\n * If that's not available either, it'll return `null`.\n *\n * Channel objects have a `type` property which is either `\"atomics\"` or `\"serviceWorker\"`.\n * The other properties are for internal use.\n *\n * If you want to control the type of channel,\n * you can call `makeAtomicsChannel` or `makeServiceWorkerChannel` directly.\n *\n * A single channel object shouldn't be used by multiple workers simultaneously,\n * i.e. you should only read/write one message at a time.\n */\nexport function makeChannel(\n  options: {\n    atomics?: AtomicsChannelOptions;\n    serviceWorker?: ServiceWorkerChannelOptions;\n  } = {},\n): Channel | null {\n  if (typeof SharedArrayBuffer !== \"undefined\") {\n    return makeAtomicsChannel(options.atomics);\n  } else if (\"serviceWorker\" in navigator) {\n    return makeServiceWorkerChannel(options.serviceWorker);\n  } else {\n    return null;\n  }\n}\n\nexport function makeAtomicsChannel({\n  bufferSize,\n}: AtomicsChannelOptions = {}): AtomicsChannel {\n  const data = new Uint8Array(new SharedArrayBuffer(bufferSize || 128 * 1024));\n  const meta = new Int32Array(\n    new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 2),\n  );\n  return {type: \"atomics\", data, meta};\n}\n\nexport function makeServiceWorkerChannel(\n  options: ServiceWorkerChannelOptions = {},\n): ServiceWorkerChannel {\n  const baseUrl = (options.scope || \"/\") + BASE_URL_SUFFIX;\n  return {type: \"serviceWorker\", baseUrl, timeout: options.timeout || 5000};\n}\n\nfunction ensurePositiveNumber(n: number, defaultValue: number) {\n  return n > 0 ? +n : defaultValue;\n}\n\n/**\n * Call this in a web worker to synchronously receive a message sent by the main thread with `writeMessage`.\n *\n * @param channel a non-null object returned by `makeChannel`, `makeAtomicsChannel`, or `makeServiceWorkerChannel`.\n *                Should be created once in the main thread and then sent to the worker.\n * @param messageId a unique string identifying the message that the worker is waiting for.\n *                  Currently only used by service worker channels.\n *                  Typically created in the worker using the `uuidv4` function and then sent to the main thread\n *                  *before* calling `readMessage`.\n * @param checkInterrupt a function which may be called regularly while `readMessage`\n *                       is checking for messages on the channel.\n *                       If it returns `true`, then `readMessage` will return `null`.\n * @param timeout a number of milliseconds.\n *                If this much time elapses without receiving a message, `readMessage` will return `null`.\n */\nexport function readMessage(\n  channel: Channel,\n  messageId: string,\n  {\n    checkInterrupt,\n    checkTimeout,\n    timeout,\n  }: {\n    checkInterrupt?: () => boolean;\n    checkTimeout?: number;\n    timeout?: number;\n  } = {},\n) {\n  const startTime = performance.now();\n\n  checkTimeout = ensurePositiveNumber(\n    checkTimeout,\n    checkInterrupt ? 100 : 5000,\n  );\n  const totalTimeout = ensurePositiveNumber(timeout, Number.POSITIVE_INFINITY);\n  let check;\n\n  if (channel.type === \"atomics\") {\n    const {data, meta} = channel;\n\n    check = () => {\n      if (Atomics.wait(meta, 1, 0, checkTimeout) === \"timed-out\") {\n        return null;\n      } else {\n        const size = Atomics.exchange(meta, 0, 0);\n        const bytes = data.slice(0, size);\n        Atomics.store(meta, 1, 0);\n\n        const decoder = new TextDecoder();\n        const text = decoder.decode(bytes);\n        return JSON.parse(text);\n      }\n    };\n  } else {\n    check = () => {\n      const request = new XMLHttpRequest();\n      // `false` makes the request synchronous\n      const url = channel.baseUrl + \"/read\";\n      request.open(\"POST\", url, false);\n      const requestBody: ServiceWorkerReadRequest = {\n        messageId,\n        timeout: checkTimeout,\n      };\n      request.send(JSON.stringify(requestBody));\n      const {status} = request;\n\n      if (status === 408) {\n        return null;\n      } else if (status === 200) {\n        const response = JSON.parse(request.responseText);\n        if (response.version !== VERSION) {\n          return null;\n        }\n        return response.message;\n      } else if (performance.now() - startTime < channel.timeout) {\n        return null;\n      } else {\n        throw new ServiceWorkerError(url, status);\n      }\n    };\n  }\n\n  while (true) {\n    const elapsed = performance.now() - startTime;\n    const remaining = totalTimeout - elapsed;\n    if (remaining <= 0) {\n      return null;\n    }\n\n    checkTimeout = Math.min(checkTimeout, remaining);\n    const result = check();\n\n    if (result !== null) {\n      return result;\n    } else if (checkInterrupt?.()) {\n      return null;\n    }\n  }\n}\n\n/**\n * Synchronously waits until the given time has elapsed without wasting CPU in a busy loop,\n * but not very accurate.\n */\nexport function syncSleep(ms: number, channel: Channel) {\n  ms = ensurePositiveNumber(ms, 0);\n  if (!ms) {\n    return;\n  }\n\n  if (typeof SharedArrayBuffer !== \"undefined\") {\n    const arr = new Int32Array(\n      new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT),\n    );\n    arr[0] = 0;\n    Atomics.wait(arr, 0, 0, ms);\n  } else {\n    const messageId = `sleep ${ms} ${uuidv4()}`;\n    readMessage(channel, messageId, {timeout: ms});\n  }\n}\n\n/**\n * Returns a unique random string in UUID v4 format.\n * Uses `crypto.randomUUID` directly if possible.\n * Otherwise uses a custom implementation which uses `crypto.getRandomValues`.\n */\nexport let uuidv4: () => string;\n\nif (\"randomUUID\" in crypto) {\n  uuidv4 = function uuidv4() {\n    return (crypto as any).randomUUID();\n  };\n} else {\n  // https://stackoverflow.com/a/2117523/2482744\n  uuidv4 = function uuidv4() {\n    return \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, (char) => {\n      const c = Number(char);\n      return (\n        c ^\n        (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))\n      ).toString(16);\n    });\n  };\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport type { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\nexport const finalizer = Symbol(\"Comlink.finalizer\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\ntype PendingListenersMap = Map<\n  string,\n  (value: WireValue | PromiseLike<WireValue>) => void\n>;\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nfunction isAllowedOrigin(\n  allowedOrigins: (string | RegExp)[],\n  origin: string\n): boolean {\n  for (const allowedOrigin of allowedOrigins) {\n    if (origin === allowedOrigin || allowedOrigin === \"*\") {\n      return true;\n    }\n    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function expose(\n  obj: any,\n  ep: Endpoint = globalThis as any,\n  allowedOrigins: (string | RegExp)[] = [\"*\"]\n) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n          if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n            obj[finalizer]();\n          }\n        }\n      })\n      .catch((error) => {\n        // Send Serialization Error To Caller\n        const [wireValue, transferables] = toWireValue({\n          value: new TypeError(\"Unserializable return value\"),\n          [throwMarker]: 0,\n        });\n        ep.postMessage({ ...wireValue, id }, transferables);\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  const pendingListeners : PendingListenersMap = new Map();\n\n  ep.addEventListener(\"message\", function handleMessage(ev: Event) {\n    const { data } = ev as MessageEvent;\n    if (!data || !data.id) {\n      return;\n    }\n    const resolver = pendingListeners.get(data.id);\n    if (!resolver) {\n      return;\n    }\n\n    try {\n      resolver(data);\n    } finally {\n      pendingListeners.delete(data.id);\n    }\n  });\n\n  return createProxy<T>(ep, pendingListeners, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction releaseEndpoint(ep: Endpoint) {\n  return requestResponseMessage(ep, new Map(), {\n    type: MessageType.RELEASE,\n  }).then(() => {\n    closeEndPoint(ep);\n  });\n}\n\ninterface FinalizationRegistry<T> {\n  new (cb: (heldValue: T) => void): FinalizationRegistry<T>;\n  register(\n    weakItem: object,\n    heldValue: T,\n    unregisterToken?: object | undefined\n  ): void;\n  unregister(unregisterToken: object): void;\n}\ndeclare var FinalizationRegistry: FinalizationRegistry<Endpoint>;\n\nconst proxyCounter = new WeakMap<Endpoint, number>();\nconst proxyFinalizers =\n  \"FinalizationRegistry\" in globalThis &&\n  new FinalizationRegistry((ep: Endpoint) => {\n    const newCount = (proxyCounter.get(ep) || 0) - 1;\n    proxyCounter.set(ep, newCount);\n    if (newCount === 0) {\n      releaseEndpoint(ep);\n    }\n  });\n\nfunction registerProxy(proxy: object, ep: Endpoint) {\n  const newCount = (proxyCounter.get(ep) || 0) + 1;\n  proxyCounter.set(ep, newCount);\n  if (proxyFinalizers) {\n    proxyFinalizers.register(proxy, ep, proxy);\n  }\n}\n\nfunction unregisterProxy(proxy: object) {\n  if (proxyFinalizers) {\n    proxyFinalizers.unregister(proxy);\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  pendingListeners: PendingListenersMap,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          unregisterProxy(proxy);\n          releaseEndpoint(ep);\n          pendingListeners.clear();\n          isProxyReleased = true;\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, pendingListeners, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, pendingListeners, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \\_()_/\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        pendingListeners,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, pendingListeners, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didnt happen.\n      if (last === \"bind\") {\n        return createProxy(ep, pendingListeners, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        pendingListeners,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        pendingListeners,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  registerProxy(proxy, ep);\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T extends {}>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = globalThis,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  pendingListeners: PendingListenersMap,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    pendingListeners.set(id, resolve);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n});\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/PythonVidya/\";","/* eslint-disable */\n// Otherwise webpack fails silently\n// https://github.com/facebook/create-react-app/issues/8014\n\nimport * as Comlink from 'comlink';\nimport pythonCoreUrl from \"./python_core.tar.load_by_url\"\nimport {\n  loadPyodideAndPackage,\n  makeRunnerCallback,\n  pyodideExpose,\n  PyodideFatalErrorReloader\n} from \"pyodide-worker-runner\";\n\nconst reloader = new PyodideFatalErrorReloader(async () => {\n  const pyodide = await loadPyodideAndPackage({url: pythonCoreUrl, format: \"tar\"});\n  pyodide.pyimport(\"core.init_pyodide\").init(process.env.REACT_APP_LANGUAGE);\n  return pyodide;\n});\n\nlet programCount = 1;\n\nconst runCode = pyodideExpose(\n  async function (extras, entry, outputCallback, inputCallback) {\n    let outputPromise;\n    const callback = makeRunnerCallback(extras, {\n      input: () => inputCallback(),\n      output: (parts) => {\n        outputPromise = outputCallback(parts);\n      },\n    });\n\n    return await reloader.withPyodide(async (pyodide) => {\n      const pyodide_worker_runner = pyodide.pyimport(\"pyodide_worker_runner\");\n      try {\n        await pyodide_worker_runner.install_imports(entry.input);\n      } catch (e) {\n        console.error(e);\n      }\n\n      const checkerModule = pyodide.pyimport(\"core.checker\");\n      checkerModule.default_runner.set_filename(`/my_program_${programCount++}.py`)\n      const result = checkerModule.check_entry(entry, callback);\n      await outputPromise;\n      return result.toJs({dict_converter: Object.fromEntries});\n    });\n  },\n);\n\nComlink.expose({runCode});\n"],"names":["e","t","self","module","exports","require","r","i","n","s","__esModule","default","d","a","o","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Error","constructor","type","workerCreator","channel","state","_messageIdBase","_messageIdSeq","this","_start","interrupt","interrupter","terminate","_writeMessage","interrupted","_len","arguments","length","Array","_key","uuidv4","_awaitingMessageResolve","_interruptPromise","Promise","_interruptRejector","race","proxy","_reset","writeMessage","message","workerProxy","releaseProxy","worker","l","wrap","h","_len2","_key2","u","readMessage","syncSleep","timeout","operation","timeouts","forever","retries","unref","maxRetryTime","concat","factor","minTimeout","maxTimeout","randomize","push","createTimeout","sort","Math","random","round","max","pow","min","slice","pop","retry","mainError","apply","attempt","bind","options","_originalTimeouts","JSON","parse","stringify","_timeouts","_options","_maxRetryTime","_fn","_errors","_attempts","_operationTimeout","_operationTimeoutCb","_timeout","_operationStart","_timer","_cachedTimeouts","reset","stop","clearTimeout","Date","getTime","unshift","shift","splice","setTimeout","cb","try","console","log","start","errors","attempts","Set","super","originalError","stack","name","globalThis","DOMException","async","onFailedAttempt","TypeError","has","attemptNumber","retriesLeft","signal","aborted","addEventListener","reason","once","Z","undefined","p","version","loadPyodide","indexURL","m","split","map","Number","format","extractDir","url","all","_","fetch","ok","status","statusText","arrayBuffer","set","unpackArchive","pyimport","path","append","f","registerComlink","Path","mkdir","write_text","Map","y","toJs","dict_converter","fromEntries","input","prompt","output","parts","other","seconds","g","syncExpose","assign","interruptBuffer","v","SyncClient","SharedArrayBuffer","Int32Array","BYTES_PER_ELEMENT","b","loader","pyodidePromise","withPyodide","pyodide_fatal_error","eval","__webpack_require__","request","includes","respondWith","Response","endsWith","messageId","json","early","c","setPrototypeOf","TextEncoder","encode","data","meta","Atomics","store","notify","navigator","serviceWorker","ready","baseUrl","now","method","body","atomics","bufferSize","Uint8Array","scope","checkInterrupt","checkTimeout","performance","POSITIVE_INFINITY","check","wait","exchange","TextDecoder","decode","XMLHttpRequest","open","send","responseText","w","crypto","randomUUID","replace","getRandomValues","toString","proxyMarker","createEndpoint","finalizer","throwMarker","isObject","val","transferHandlers","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","_ref","serialized","isError","ep","allowedOrigins","callback","ev","origin","allowedOrigin","RegExp","test","isAllowedOrigin","warn","id","argumentList","fromWireValue","returnValue","parent","reduce","prop","rawValue","transfer","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","endpoint","isMessagePort","close","target","pendingListeners","resolver","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","arr","transferCache","transfers","windowEndpoint","context","targetOrigin","msg","handler","serializedValue","fill","floor","MAX_SAFE_INTEGER","join","__webpack_module_cache__","moduleId","cachedModule","__webpack_modules__","definition","key","reloader","PyodideFatalErrorReloader","pyodide","loadPyodideAndPackage","pythonCoreUrl","init","process","REACT_APP_LANGUAGE","programCount","runCode","pyodideExpose","extras","entry","outputCallback","inputCallback","outputPromise","makeRunnerCallback","pyodide_worker_runner","install_imports","checkerModule","default_runner","set_filename","result","check_entry","Comlink"],"sourceRoot":""}